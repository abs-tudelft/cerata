<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cerata: cerata Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cerata.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cerata
   </div>
   <div id="projectbrief">A library to generate structural hardware designs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacecerata.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cerata Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains every Cerata class, function, etc...  
<a href="namespacecerata.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecerata_1_1dot"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata_1_1dot.html">dot</a></td></tr>
<tr class="memdesc:namespacecerata_1_1dot"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains everything related to the DOT back-end. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecerata_1_1vhdl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata_1_1vhdl.html">vhdl</a></td></tr>
<tr class="memdesc:namespacecerata_1_1vhdl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains everything related to the VHDL back-end. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_bit.html">Bit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit type.  <a href="structcerata_1_1_bit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_boolean.html">Boolean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcerata_1_1_boolean.html" title="Boolean type.">Boolean</a> type.  <a href="structcerata_1_1_boolean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clock domain.  <a href="structcerata_1_1_clock_domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_component.html">Component</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_component.html" title="A Component graph.">Component</a> graph.  <a href="classcerata_1_1_component.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_component_pool.html">ComponentPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool of Components.  <a href="classcerata_1_1_component_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A directed edge between two nodes.  <a href="classcerata_1_1_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node representing a binary tree of other nodes.  <a href="classcerata_1_1_expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_field.html">Field</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> field.  <a href="classcerata_1_1_field.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_flat_type.html">FlatType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flattened type.  <a href="structcerata_1_1_flat_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A graph representing a hardware structure.  <a href="classcerata_1_1_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_instance.html">Instance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance.  <a href="classcerata_1_1_instance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_integer.html">Integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcerata_1_1_integer.html" title="Integer type.">Integer</a> type.  <a href="structcerata_1_1_integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_literal.html">Literal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_literal.html" title="A Literal Node.">Literal</a> <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a>.  <a href="classcerata_1_1_literal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcerata_1_1_logger.html" title="Logger class.">Logger</a> class.  <a href="classcerata_1_1_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_mapping_matrix.html">MappingMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix used for <a class="el" href="classcerata_1_1_type_mapper.html" title="A structure to dynamically define type mappings between flattened types.">TypeMapper</a>.  <a href="classcerata_1_1_mapping_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_mapping_pair.html">MappingPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing a mapping pair for a type mapping.  <a href="structcerata_1_1_mapping_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_multi_output_node.html">MultiOutputNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-input, multiple-outputs node.  <a href="structcerata_1_1_multi_output_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_named.html">Named</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience structure for anything that is named. Names are case-sensitive.  <a href="structcerata_1_1_named.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_name_part.html">NamePart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience struct to generate names in parts.  <a href="structcerata_1_1_name_part.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node.  <a href="classcerata_1_1_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_node_array.html">NodeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of nodes.  <a href="classcerata_1_1_node_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_node_pool.html">NodePool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool of nodes.  <a href="classcerata_1_1_node_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_normal_node.html">NormalNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-input, multiple-outputs node.  <a href="structcerata_1_1_normal_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Cerata <a class="el" href="classcerata_1_1_object.html" title="A Cerata Object on a graph.">Object</a> on a graph.  <a href="classcerata_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_output_generator.html">OutputGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class to generate language specific output from Graphs.  <a href="classcerata_1_1_output_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_output_spec.html">OutputSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to specify output properties per graph.  <a href="structcerata_1_1_output_spec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_parameter.html" title="A Parameter node.">Parameter</a> node.  <a href="classcerata_1_1_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_pool.html">Pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool to share ownership of objects.  <a href="classcerata_1_1_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_port.html">Port</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A port is a terminator node on a graph.  <a href="classcerata_1_1_port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_port_array.html">PortArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of port nodes.  <a href="classcerata_1_1_port_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_record.html">Record</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type containing zero or more fields.  <a href="classcerata_1_1_record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_signal.html">Signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a> <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a>.  <a href="classcerata_1_1_signal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_signal_array.html">SignalArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of signal nodes.  <a href="classcerata_1_1_signal_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type.  <a href="classcerata_1_1_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcerata_1_1_string.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcerata_1_1_string.html" title="String type.">String</a> type.  <a href="structcerata_1_1_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_synchronous.html">Synchronous</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to mark nodes with information for synchronous designs, e.g. clock domain.  <a href="classcerata_1_1_synchronous.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_term.html">Term</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A terminator structure to enable terminator sanity checks.  <a href="classcerata_1_1_term.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a>.  <a href="classcerata_1_1_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_type_mapper.html">TypeMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to dynamically define type mappings between flattened types.  <a href="classcerata_1_1_type_mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_type_pool.html">TypePool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool of Types.  <a href="classcerata_1_1_type_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcerata_1_1_vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcerata_1_1_vector.html" title="Vector type.">Vector</a> type.  <a href="classcerata_1_1_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3fcbbd525dac4039659ccb1f5a6bb256"><td class="memItemLeft" align="right" valign="top"><a id="a3fcbbd525dac4039659ccb1f5a6bb256"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a> = int</td></tr>
<tr class="memdesc:a3fcbbd525dac4039659ccb1f5a6bb256"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a> used for the logging level. <br /></td></tr>
<tr class="separator:a3fcbbd525dac4039659ccb1f5a6bb256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadbf80a46cf891ebe1a1defc66cecb9"><td class="memItemLeft" align="right" valign="top"><a id="aaadbf80a46cf891ebe1a1defc66cecb9"></a>
typedef std::unordered_map&lt; const <a class="el" href="classcerata_1_1_node.html">Node</a> *, <a class="el" href="classcerata_1_1_node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aaadbf80a46cf891ebe1a1defc66cecb9">NodeMap</a></td></tr>
<tr class="memdesc:aaadbf80a46cf891ebe1a1defc66cecb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping from one object to another object, used in e.g. type generic rebinding. <br /></td></tr>
<tr class="separator:aaadbf80a46cf891ebe1a1defc66cecb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7168a1743c7fe50ad70951baf43677"><td class="memItemLeft" align="right" valign="top"><a id="acf7168a1743c7fe50ad70951baf43677"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Status</b> = putong::Status&lt; <a class="el" href="namespacecerata.html#a2e998b720abc2a667a6b5d28cc90a78d">Error</a> &gt;</td></tr>
<tr class="separator:acf7168a1743c7fe50ad70951baf43677"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2e998b720abc2a667a6b5d28cc90a78d"><td class="memItemLeft" align="right" valign="top"><a id="a2e998b720abc2a667a6b5d28cc90a78d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a2e998b720abc2a667a6b5d28cc90a78d">Error</a> { <b>GenericError</b>, 
<b>YAMLError</b>
 }</td></tr>
<tr class="memdesc:a2e998b720abc2a667a6b5d28cc90a78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error types. <br /></td></tr>
<tr class="separator:a2e998b720abc2a667a6b5d28cc90a78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2c7a5d2d5d88460064a986e497d3f954"><td class="memItemLeft" align="right" valign="top"><a id="a2c7a5d2d5d88460064a986e497d3f954"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_port_array.html">PortArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a2c7a5d2d5d88460064a986e497d3f954">port_array</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;type, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;size, <a class="el" href="classcerata_1_1_term.html#ad5d2b86b16059306d8dbf73a0c972dad">Port::Dir</a> dir=Port::Dir::IN, const std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt; &amp;domain=<a class="el" href="namespacecerata.html#a54354555fa54fe1eb3a916d4e00b8103">default_domain</a>())</td></tr>
<tr class="memdesc:a2c7a5d2d5d88460064a986e497d3f954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a smart pointer to a new ArrayPort. <br /></td></tr>
<tr class="separator:a2c7a5d2d5d88460064a986e497d3f954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcd7f10bc9b2a34fbd4f5824d2f0f07"><td class="memItemLeft" align="right" valign="top"><a id="a5dcd7f10bc9b2a34fbd4f5824d2f0f07"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_port_array.html">PortArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5dcd7f10bc9b2a34fbd4f5824d2f0f07">port_array</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_port.html">Port</a> &gt; &amp;base_node, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;size)</td></tr>
<tr class="memdesc:a5dcd7f10bc9b2a34fbd4f5824d2f0f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a smart pointer to a new ArrayPort with a base type other than the default <a class="el" href="classcerata_1_1_port.html" title="A port is a terminator node on a graph.">Port</a>. <br /></td></tr>
<tr class="separator:a5dcd7f10bc9b2a34fbd4f5824d2f0f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4f0ee8ed52feb08a7124933579b63d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_signal_array.html">SignalArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a1a4f0ee8ed52feb08a7124933579b63d">signal_array</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;type, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;size, const std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt; &amp;domain=<a class="el" href="namespacecerata.html#a54354555fa54fe1eb3a916d4e00b8103">default_domain</a>())</td></tr>
<tr class="memdesc:a1a4f0ee8ed52feb08a7124933579b63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new node array and return a shared pointer to it.  <a href="namespacecerata.html#a1a4f0ee8ed52feb08a7124933579b63d">More...</a><br /></td></tr>
<tr class="separator:a1a4f0ee8ed52feb08a7124933579b63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54354555fa54fe1eb3a916d4e00b8103"><td class="memItemLeft" align="right" valign="top"><a id="a54354555fa54fe1eb3a916d4e00b8103"></a>
std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a54354555fa54fe1eb3a916d4e00b8103">default_domain</a> ()</td></tr>
<tr class="memdesc:a54354555fa54fe1eb3a916d4e00b8103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a static default clock domain. <br /></td></tr>
<tr class="separator:a54354555fa54fe1eb3a916d4e00b8103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b87fba2894a37705b13a5557b474a88"><td class="memItemLeft" align="right" valign="top"><a id="a8b87fba2894a37705b13a5557b474a88"></a>
std::optional&lt; std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a8b87fba2894a37705b13a5557b474a88">GetDomain</a> (const <a class="el" href="classcerata_1_1_node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a8b87fba2894a37705b13a5557b474a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the clock domain of a node, if it is a synchronous node. <br /></td></tr>
<tr class="separator:a8b87fba2894a37705b13a5557b474a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a4a91a13db9c5da9a901069a1fa244"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a75a4a91a13db9c5da9a901069a1fa244">Connect</a> (<a class="el" href="classcerata_1_1_node.html">Node</a> *dst, <a class="el" href="classcerata_1_1_node.html">Node</a> *src)</td></tr>
<tr class="memdesc:a75a4a91a13db9c5da9a901069a1fa244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two nodes, returns the corresponding edge.  <a href="namespacecerata.html#a75a4a91a13db9c5da9a901069a1fa244">More...</a><br /></td></tr>
<tr class="separator:a75a4a91a13db9c5da9a901069a1fa244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac498abd92d47ff70c70b03a90aa60b6d"><td class="memItemLeft" align="right" valign="top"><a id="ac498abd92d47ff70c70b03a90aa60b6d"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ac498abd92d47ff70c70b03a90aa60b6d">operator&lt;&lt;=</a> (<a class="el" href="classcerata_1_1_node.html">Node</a> *dst, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:ac498abd92d47ff70c70b03a90aa60b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge, connecting the src node to the dst node. <br /></td></tr>
<tr class="separator:ac498abd92d47ff70c70b03a90aa60b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10336e8259628bebb216f2d24755ec5"><td class="memItemLeft" align="right" valign="top"><a id="ad10336e8259628bebb216f2d24755ec5"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ad10336e8259628bebb216f2d24755ec5">operator&lt;&lt;=</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;dst, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:ad10336e8259628bebb216f2d24755ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge, connecting the src node to the dst node. <br /></td></tr>
<tr class="separator:ad10336e8259628bebb216f2d24755ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7afb718d3737c0529e39807e8ee901e"><td class="memItemLeft" align="right" valign="top"><a id="af7afb718d3737c0529e39807e8ee901e"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#af7afb718d3737c0529e39807e8ee901e">operator&lt;&lt;=</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;dst, <a class="el" href="classcerata_1_1_node.html">Node</a> *src)</td></tr>
<tr class="memdesc:af7afb718d3737c0529e39807e8ee901e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge, connecting the src node to the dst node. <br /></td></tr>
<tr class="separator:af7afb718d3737c0529e39807e8ee901e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee6dbbc86186014e4fd884b1932d93c"><td class="memItemLeft" align="right" valign="top"><a id="a7ee6dbbc86186014e4fd884b1932d93c"></a>
std::vector&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a7ee6dbbc86186014e4fd884b1932d93c">GetAllEdges</a> (const <a class="el" href="classcerata_1_1_graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a7ee6dbbc86186014e4fd884b1932d93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain all edges in a graph. <br /></td></tr>
<tr class="separator:a7ee6dbbc86186014e4fd884b1932d93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21edb913c7d1cdd7e44c7bf4eaf4b6f8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a21edb913c7d1cdd7e44c7bf4eaf4b6f8">Connect</a> (<a class="el" href="classcerata_1_1_node.html">Node</a> *dst, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:a21edb913c7d1cdd7e44c7bf4eaf4b6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two nodes, returns the corresponding edge.  <a href="namespacecerata.html#a21edb913c7d1cdd7e44c7bf4eaf4b6f8">More...</a><br /></td></tr>
<tr class="separator:a21edb913c7d1cdd7e44c7bf4eaf4b6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5420154c855d31f11018dcd6c183502"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ac5420154c855d31f11018dcd6c183502">Connect</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;dst, <a class="el" href="classcerata_1_1_node.html">Node</a> *src)</td></tr>
<tr class="memdesc:ac5420154c855d31f11018dcd6c183502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two nodes, returns the corresponding edge.  <a href="namespacecerata.html#ac5420154c855d31f11018dcd6c183502">More...</a><br /></td></tr>
<tr class="separator:ac5420154c855d31f11018dcd6c183502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bca1eba253dcd02cce5b31a09a239a8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a7bca1eba253dcd02cce5b31a09a239a8">Connect</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;dst, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;src)</td></tr>
<tr class="memdesc:a7bca1eba253dcd02cce5b31a09a239a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect two nodes, returns the corresponding edge.  <a href="namespacecerata.html#a7bca1eba253dcd02cce5b31a09a239a8">More...</a><br /></td></tr>
<tr class="separator:a7bca1eba253dcd02cce5b31a09a239a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3d7c4f3efb99d3dcee77c87024208f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_signal.html">Signal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aae3d7c4f3efb99d3dcee77c87024208f">AttachSignalToNode</a> (<a class="el" href="classcerata_1_1_component.html">Component</a> *comp, <a class="el" href="structcerata_1_1_normal_node.html">NormalNode</a> *node, <a class="el" href="namespacecerata.html#aaadbf80a46cf891ebe1a1defc66cecb9">NodeMap</a> *rebinding, std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:aae3d7c4f3efb99d3dcee77c87024208f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a> to a <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a>, redirecting all edges through the new <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a>.  <a href="namespacecerata.html#aae3d7c4f3efb99d3dcee77c87024208f">More...</a><br /></td></tr>
<tr class="separator:aae3d7c4f3efb99d3dcee77c87024208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7554850cf2775a320602b3739d980bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_signal_array.html">SignalArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aa7554850cf2775a320602b3739d980bf">AttachSignalArrayToNodeArray</a> (<a class="el" href="classcerata_1_1_component.html">Component</a> *comp, <a class="el" href="classcerata_1_1_node_array.html">NodeArray</a> *array, <a class="el" href="namespacecerata.html#aaadbf80a46cf891ebe1a1defc66cecb9">NodeMap</a> *rebinding)</td></tr>
<tr class="memdesc:aa7554850cf2775a320602b3739d980bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a <a class="el" href="classcerata_1_1_signal_array.html" title="An array of signal nodes.">SignalArray</a> to a <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a>, redirecting all edges through the new <a class="el" href="classcerata_1_1_signal_array.html" title="An array of signal nodes.">SignalArray</a>.  <a href="namespacecerata.html#aa7554850cf2775a320602b3739d980bf">More...</a><br /></td></tr>
<tr class="separator:aa7554850cf2775a320602b3739d980bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f7364223f66e39d88afa42d116f3f4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a95f7364223f66e39d88afa42d116f3f4">Connect</a> (<a class="el" href="classcerata_1_1_node.html">Node</a> *dst, std::string str)</td></tr>
<tr class="memdesc:a95f7364223f66e39d88afa42d116f3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect a string literal to another node.  <a href="namespacecerata.html#a95f7364223f66e39d88afa42d116f3f4">More...</a><br /></td></tr>
<tr class="separator:a95f7364223f66e39d88afa42d116f3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566331b4acf7f5d9dbd78720f22447f8"><td class="memItemLeft" align="right" valign="top"><a id="a566331b4acf7f5d9dbd78720f22447f8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a566331b4acf7f5d9dbd78720f22447f8">ToString</a> (<a class="el" href="classcerata_1_1_expression.html#ab9e0d7d014077b256215d4873ef47454">Expression::Op</a> operation)</td></tr>
<tr class="memdesc:a566331b4acf7f5d9dbd78720f22447f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Human-readable expression operator. <br /></td></tr>
<tr class="separator:a566331b4acf7f5d9dbd78720f22447f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff94e0deacf044a10e049e6693a451f"><td class="memItemLeft" align="right" valign="top"><a id="aeff94e0deacf044a10e049e6693a451f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aeff94e0deacf044a10e049e6693a451f">operator&lt;</a> (const <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &amp;a, const <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &amp;b)</td></tr>
<tr class="memdesc:aeff94e0deacf044a10e049e6693a451f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two FlatTypes first by name, then by nesting level. Useful for sorting. <br /></td></tr>
<tr class="separator:aeff94e0deacf044a10e049e6693a451f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3101cf6f1ed9c57c916feb2363cf5f2a"><td class="memItemLeft" align="right" valign="top"><a id="a3101cf6f1ed9c57c916feb2363cf5f2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a3101cf6f1ed9c57c916feb2363cf5f2a">FlattenRecord</a> (std::vector&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; *list, const <a class="el" href="classcerata_1_1_record.html">Record</a> *<a class="el" href="namespacecerata.html#a4fc8a4ad689357b0d71c15b08860c318">record</a>, const std::optional&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;parent, bool invert)</td></tr>
<tr class="memdesc:a3101cf6f1ed9c57c916feb2363cf5f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a>. <br /></td></tr>
<tr class="separator:a3101cf6f1ed9c57c916feb2363cf5f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07cd4091dbe41fd7e436aafc6afdbee"><td class="memItemLeft" align="right" valign="top"><a id="ae07cd4091dbe41fd7e436aafc6afdbee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ae07cd4091dbe41fd7e436aafc6afdbee">Flatten</a> (std::vector&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; *list, <a class="el" href="classcerata_1_1_type.html">Type</a> *type, const std::optional&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;parent, const std::string &amp;name, bool invert, bool sep=true)</td></tr>
<tr class="memdesc:ae07cd4091dbe41fd7e436aafc6afdbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten any <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a>. <br /></td></tr>
<tr class="separator:ae07cd4091dbe41fd7e436aafc6afdbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192c6400ac833d29566506edcdd62ade"><td class="memItemLeft" align="right" valign="top"><a id="a192c6400ac833d29566506edcdd62ade"></a>
std::vector&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a192c6400ac833d29566506edcdd62ade">Flatten</a> (<a class="el" href="classcerata_1_1_type.html">Type</a> *type)</td></tr>
<tr class="memdesc:a192c6400ac833d29566506edcdd62ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten and return a list of FlatTypes. <br /></td></tr>
<tr class="separator:a192c6400ac833d29566506edcdd62ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae881e12d8edc4b4bf4fd3b76512242b"><td class="memItemLeft" align="right" valign="top"><a id="aae881e12d8edc4b4bf4fd3b76512242b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aae881e12d8edc4b4bf4fd3b76512242b">ToString</a> (std::vector&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; flat_type_list)</td></tr>
<tr class="memdesc:aae881e12d8edc4b4bf4fd3b76512242b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of FlatTypes to a human-readable string. <br /></td></tr>
<tr class="separator:aae881e12d8edc4b4bf4fd3b76512242b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac844dedc9760b2bbd68fcc647cbb98b6"><td class="memItemLeft" align="right" valign="top"><a id="ac844dedc9760b2bbd68fcc647cbb98b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ac844dedc9760b2bbd68fcc647cbb98b6">ContainsFlatType</a> (const std::vector&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;flat_types_list, const <a class="el" href="classcerata_1_1_type.html">Type</a> *type)</td></tr>
<tr class="memdesc:ac844dedc9760b2bbd68fcc647cbb98b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if some <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a> is contained in a list of FlatTypes, false otherwise. <br /></td></tr>
<tr class="separator:ac844dedc9760b2bbd68fcc647cbb98b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51698c92c200fcdf7b2a595d39dd4630"><td class="memItemLeft" align="right" valign="top"><a id="a51698c92c200fcdf7b2a595d39dd4630"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a51698c92c200fcdf7b2a595d39dd4630">IndexOfFlatType</a> (const std::vector&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;flat_types_list, const <a class="el" href="classcerata_1_1_type.html">Type</a> *type)</td></tr>
<tr class="memdesc:a51698c92c200fcdf7b2a595d39dd4630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of some <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a> in a list of FlatTypes. <br /></td></tr>
<tr class="separator:a51698c92c200fcdf7b2a595d39dd4630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82665ac3cb8f346131d443e8674ff301"><td class="memItemLeft" align="right" valign="top"><a id="a82665ac3cb8f346131d443e8674ff301"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a82665ac3cb8f346131d443e8674ff301">FlattenStream</a> (std::vector&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; *list, const <a class="el" href="classcerata_1_1_stream.html">Stream</a> *<a class="el" href="namespacecerata.html#a8360c23043de7477e20798a05deb87a3">stream</a>, const std::optional&lt; <a class="el" href="structcerata_1_1_flat_type.html">FlatType</a> &gt; &amp;parent, bool invert)</td></tr>
<tr class="memdesc:a82665ac3cb8f346131d443e8674ff301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a>. <br /></td></tr>
<tr class="separator:a82665ac3cb8f346131d443e8674ff301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c27e02e7ff01f243c2c11ad8a59375"><td class="memItemLeft" align="right" valign="top"><a id="a16c27e02e7ff01f243c2c11ad8a59375"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_component.html">Component</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a16c27e02e7ff01f243c2c11ad8a59375">component</a> (std::string name, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcerata_1_1_object.html">Object</a> &gt;&gt; &amp;nodes, <a class="el" href="classcerata_1_1_component_pool.html">ComponentPool</a> *component_pool=<a class="el" href="namespacecerata.html#a5507f0a68a372e488c19f4f194fefffd">default_component_pool</a>())</td></tr>
<tr class="memdesc:a16c27e02e7ff01f243c2c11ad8a59375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classcerata_1_1_component.html" title="A Component graph.">Component</a> with initial nodes. <br /></td></tr>
<tr class="separator:a16c27e02e7ff01f243c2c11ad8a59375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13eae8a6e315f697bf5009463c39a785"><td class="memItemLeft" align="right" valign="top"><a id="a13eae8a6e315f697bf5009463c39a785"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_component.html">Component</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a13eae8a6e315f697bf5009463c39a785">component</a> (std::string name, <a class="el" href="classcerata_1_1_component_pool.html">ComponentPool</a> *component_pool=<a class="el" href="namespacecerata.html#a5507f0a68a372e488c19f4f194fefffd">default_component_pool</a>())</td></tr>
<tr class="memdesc:a13eae8a6e315f697bf5009463c39a785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="classcerata_1_1_component.html" title="A Component graph.">Component</a> with only a name. <br /></td></tr>
<tr class="separator:a13eae8a6e315f697bf5009463c39a785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa199912b79794ece2bf4f491251833d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa199912b79794ece2bf4f491251833d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aaa199912b79794ece2bf4f491251833d">RawValueOf</a> (const <a class="el" href="classcerata_1_1_literal.html">Literal</a> &amp;node)</td></tr>
<tr class="memdesc:aaa199912b79794ece2bf4f491251833d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the raw value of a literal node.  <a href="namespacecerata.html#aaa199912b79794ece2bf4f491251833d">More...</a><br /></td></tr>
<tr class="separator:aaa199912b79794ece2bf4f491251833d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed3d124db6df73c0acdb6b6191a59cf"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6ed3d124db6df73c0acdb6b6191a59cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a6ed3d124db6df73c0acdb6b6191a59cf">RawValueOf</a> (const <a class="el" href="classcerata_1_1_literal.html">Literal</a> &amp;node)</td></tr>
<tr class="memdesc:a6ed3d124db6df73c0acdb6b6191a59cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for RawValueOf&lt;bool&gt;  <a href="namespacecerata.html#a6ed3d124db6df73c0acdb6b6191a59cf">More...</a><br /></td></tr>
<tr class="separator:a6ed3d124db6df73c0acdb6b6191a59cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709d4b62709694510baba580d4910c34"><td class="memTemplParams" colspan="2"><a id="a709d4b62709694510baba580d4910c34"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a709d4b62709694510baba580d4910c34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899">Literal::StorageType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a709d4b62709694510baba580d4910c34">StorageTypeOf</a> ()</td></tr>
<tr class="memdesc:a709d4b62709694510baba580d4910c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899" title="The storage type of the literal value.">Literal::StorageType</a> enum value of a C++ type T. <br /></td></tr>
<tr class="separator:a709d4b62709694510baba580d4910c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a27f27d87e6f67ef9efbfa114f7f33d"><td class="memItemLeft" align="right" valign="top"><a id="a7a27f27d87e6f67ef9efbfa114f7f33d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7a27f27d87e6f67ef9efbfa114f7f33d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899">Literal::StorageType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a7a27f27d87e6f67ef9efbfa114f7f33d">StorageTypeOf&lt; bool &gt;</a> ()</td></tr>
<tr class="memdesc:a7a27f27d87e6f67ef9efbfa114f7f33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for StorageTypeOf&lt;bool&gt; <br /></td></tr>
<tr class="separator:a7a27f27d87e6f67ef9efbfa114f7f33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dfe9082b93c5775afedad6088e137b"><td class="memItemLeft" align="right" valign="top"><a id="a92dfe9082b93c5775afedad6088e137b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a92dfe9082b93c5775afedad6088e137b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899">Literal::StorageType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a92dfe9082b93c5775afedad6088e137b">StorageTypeOf&lt; int64_t &gt;</a> ()</td></tr>
<tr class="memdesc:a92dfe9082b93c5775afedad6088e137b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for StorageTypeOf&lt;int&gt; <br /></td></tr>
<tr class="separator:a92dfe9082b93c5775afedad6088e137b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c7795bf96bb5f8d624da08f187abcf"><td class="memItemLeft" align="right" valign="top"><a id="aa9c7795bf96bb5f8d624da08f187abcf"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa9c7795bf96bb5f8d624da08f187abcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899">Literal::StorageType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aa9c7795bf96bb5f8d624da08f187abcf">StorageTypeOf&lt; uint64_t &gt;</a> ()</td></tr>
<tr class="memdesc:aa9c7795bf96bb5f8d624da08f187abcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for StorageTypeOf&lt;int&gt; <br /></td></tr>
<tr class="separator:aa9c7795bf96bb5f8d624da08f187abcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aa01333e4b6affc07c3e40b1e64aa9"><td class="memItemLeft" align="right" valign="top"><a id="a20aa01333e4b6affc07c3e40b1e64aa9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a20aa01333e4b6affc07c3e40b1e64aa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcerata_1_1_literal.html#a83d47bb3ef158318cb12ee577a999899">Literal::StorageType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a20aa01333e4b6affc07c3e40b1e64aa9">StorageTypeOf&lt; std::string &gt;</a> ()</td></tr>
<tr class="memdesc:a20aa01333e4b6affc07c3e40b1e64aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for <a class="el" href="namespacecerata.html#a709d4b62709694510baba580d4910c34" title="Obtain the Literal::StorageType enum value of a C++ type T.">StorageTypeOf&lt;std::string&gt;</a> <br /></td></tr>
<tr class="separator:a20aa01333e4b6affc07c3e40b1e64aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac4f24d9dec464f3964bb7923ae0a79"><td class="memItemLeft" align="right" valign="top"><a id="a2ac4f24d9dec464f3964bb7923ae0a79"></a>
<a class="el" href="classcerata_1_1_logger.html">Logger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a2ac4f24d9dec464f3964bb7923ae0a79">logger</a> ()</td></tr>
<tr class="memdesc:a2ac4f24d9dec464f3964bb7923ae0a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global Cerata logger. <br /></td></tr>
<tr class="separator:a2ac4f24d9dec464f3964bb7923ae0a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ed2ea3884e34bae8ff165006f1ff2"><td class="memItemLeft" align="right" valign="top"><a id="a4f8ed2ea3884e34bae8ff165006f1ff2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4f8ed2ea3884e34bae8ff165006f1ff2">ImplicitlyRebindNodes</a> (<a class="el" href="classcerata_1_1_graph.html">Graph</a> *dst, const std::vector&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> * &gt; &amp;nodes, <a class="el" href="namespacecerata.html#aaadbf80a46cf891ebe1a1defc66cecb9">NodeMap</a> *rebinding)</td></tr>
<tr class="memdesc:a4f8ed2ea3884e34bae8ff165006f1ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure that the NodeMap contains all nodes to be rebound onto the destination graph. <br /></td></tr>
<tr class="separator:a4f8ed2ea3884e34bae8ff165006f1ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2146118ea4459675bc1bf0879db28fc2"><td class="memItemLeft" align="right" valign="top"><a id="a2146118ea4459675bc1bf0879db28fc2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a2146118ea4459675bc1bf0879db28fc2">ToString</a> (<a class="el" href="classcerata_1_1_node.html#a648f249ae6714826366a329ac33730c0">Node::NodeID</a> id)</td></tr>
<tr class="memdesc:a2146118ea4459675bc1bf0879db28fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a> ID to a human-readable string. <br /></td></tr>
<tr class="separator:a2146118ea4459675bc1bf0879db28fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a3eb243cac49627d6594047333032f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a66a3eb243cac49627d6594047333032f">GetObjectReferences</a> (const <a class="el" href="classcerata_1_1_object.html">Object</a> &amp;obj, std::vector&lt; <a class="el" href="classcerata_1_1_object.html">Object</a> * &gt; *out)</td></tr>
<tr class="memdesc:a66a3eb243cac49627d6594047333032f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any sub-objects that are used by an object, e.g. type generic nodes or array size nodes.  <a href="namespacecerata.html#a66a3eb243cac49627d6594047333032f">More...</a><br /></td></tr>
<tr class="separator:a66a3eb243cac49627d6594047333032f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5648b64e2007b77290b7a584d5db6a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_parameter.html">Parameter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aee5648b64e2007b77290b7a584d5db6a">parameter</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;type, std::shared_ptr&lt; <a class="el" href="classcerata_1_1_literal.html">Literal</a> &gt; default_value=nullptr)</td></tr>
<tr class="memdesc:aee5648b64e2007b77290b7a584d5db6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new parameter.  <a href="namespacecerata.html#aee5648b64e2007b77290b7a584d5db6a">More...</a><br /></td></tr>
<tr class="separator:aee5648b64e2007b77290b7a584d5db6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826234cc96ef81a3c960a431231d0ba3"><td class="memItemLeft" align="right" valign="top"><a id="a826234cc96ef81a3c960a431231d0ba3"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_parameter.html">Parameter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a826234cc96ef81a3c960a431231d0ba3">parameter</a> (const std::string &amp;name, int default_value)</td></tr>
<tr class="memdesc:a826234cc96ef81a3c960a431231d0ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new integer-type parameter. <br /></td></tr>
<tr class="separator:a826234cc96ef81a3c960a431231d0ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed1d14b392e7e39c90ff1bbc5adb816"><td class="memItemLeft" align="right" valign="top"><a id="a2ed1d14b392e7e39c90ff1bbc5adb816"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_parameter.html">Parameter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a2ed1d14b392e7e39c90ff1bbc5adb816">parameter</a> (const std::string &amp;name, bool default_value)</td></tr>
<tr class="memdesc:a2ed1d14b392e7e39c90ff1bbc5adb816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new boolean-type parameter. <br /></td></tr>
<tr class="separator:a2ed1d14b392e7e39c90ff1bbc5adb816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba028281631be4062e11632b2bd47d8"><td class="memItemLeft" align="right" valign="top"><a id="a5ba028281631be4062e11632b2bd47d8"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_parameter.html">Parameter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5ba028281631be4062e11632b2bd47d8">parameter</a> (const std::string &amp;name, std::string default_value)</td></tr>
<tr class="memdesc:a5ba028281631be4062e11632b2bd47d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new string-type parameter. <br /></td></tr>
<tr class="separator:a5ba028281631be4062e11632b2bd47d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674dee7daa1ac7e739af4f00e6e9aa5f"><td class="memItemLeft" align="right" valign="top"><a id="a674dee7daa1ac7e739af4f00e6e9aa5f"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_parameter.html">Parameter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a674dee7daa1ac7e739af4f00e6e9aa5f">parameter</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a674dee7daa1ac7e739af4f00e6e9aa5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new integer-type parameter with default value 0. <br /></td></tr>
<tr class="separator:a674dee7daa1ac7e739af4f00e6e9aa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b5f9afe961078b8fa4353707433ce7"><td class="memItemLeft" align="right" valign="top"><a id="a07b5f9afe961078b8fa4353707433ce7"></a>
<a class="el" href="classcerata_1_1_type_pool.html">TypePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a07b5f9afe961078b8fa4353707433ce7">default_type_pool</a> ()</td></tr>
<tr class="memdesc:a07b5f9afe961078b8fa4353707433ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a global default <a class="el" href="classcerata_1_1_type_pool.html" title="A pool of Types.">TypePool</a>. <br /></td></tr>
<tr class="separator:a07b5f9afe961078b8fa4353707433ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5507f0a68a372e488c19f4f194fefffd"><td class="memItemLeft" align="right" valign="top"><a id="a5507f0a68a372e488c19f4f194fefffd"></a>
<a class="el" href="classcerata_1_1_component_pool.html">ComponentPool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5507f0a68a372e488c19f4f194fefffd">default_component_pool</a> ()</td></tr>
<tr class="memdesc:a5507f0a68a372e488c19f4f194fefffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a global default component pool. <br /></td></tr>
<tr class="separator:a5507f0a68a372e488c19f4f194fefffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8d91dc1beab21a259e6d40e3641ac7"><td class="memItemLeft" align="right" valign="top"><a id="acb8d91dc1beab21a259e6d40e3641ac7"></a>
<a class="el" href="classcerata_1_1_node_pool.html">NodePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#acb8d91dc1beab21a259e6d40e3641ac7">default_node_pool</a> ()</td></tr>
<tr class="memdesc:acb8d91dc1beab21a259e6d40e3641ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a global default node pool that can store nodes without being owned by a graph. <br /></td></tr>
<tr class="separator:acb8d91dc1beab21a259e6d40e3641ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7021b9d588e051e4f4ed15734f1183ff"><td class="memItemLeft" align="right" valign="top"><a id="a7021b9d588e051e4f4ed15734f1183ff"></a>
<a class="el" href="classcerata_1_1_literal.html">Literal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a7021b9d588e051e4f4ed15734f1183ff">rintl</a> (int64_t i)</td></tr>
<tr class="memdesc:a7021b9d588e051e4f4ed15734f1183ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a raw pointer to an integer literal from the default node pool. <br /></td></tr>
<tr class="separator:a7021b9d588e051e4f4ed15734f1183ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed6c9599502c2fbfd51881f2acbf6e6"><td class="memItemLeft" align="right" valign="top"><a id="a7ed6c9599502c2fbfd51881f2acbf6e6"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a7ed6c9599502c2fbfd51881f2acbf6e6">intl</a> (int64_t i)</td></tr>
<tr class="memdesc:a7ed6c9599502c2fbfd51881f2acbf6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a shared pointer to an integer literal from the default node pool. <br /></td></tr>
<tr class="separator:a7ed6c9599502c2fbfd51881f2acbf6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0bad258fc1372554a5c5c1bec86e63"><td class="memItemLeft" align="right" valign="top"><a id="a4b0bad258fc1372554a5c5c1bec86e63"></a>
<a class="el" href="classcerata_1_1_literal.html">Literal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4b0bad258fc1372554a5c5c1bec86e63">rstrl</a> (std::string str)</td></tr>
<tr class="memdesc:a4b0bad258fc1372554a5c5c1bec86e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a raw pointer to a string literal from the default node pool. <br /></td></tr>
<tr class="separator:a4b0bad258fc1372554a5c5c1bec86e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c8c87100d50ab58df7b038f2db56e9"><td class="memItemLeft" align="right" valign="top"><a id="a82c8c87100d50ab58df7b038f2db56e9"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a82c8c87100d50ab58df7b038f2db56e9">strl</a> (std::string str)</td></tr>
<tr class="memdesc:a82c8c87100d50ab58df7b038f2db56e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a shared pointer to a string literal from the default node pool. <br /></td></tr>
<tr class="separator:a82c8c87100d50ab58df7b038f2db56e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988e27720b998e85472d3e1b198a21be"><td class="memItemLeft" align="right" valign="top"><a id="a988e27720b998e85472d3e1b198a21be"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_literal.html">Literal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a988e27720b998e85472d3e1b198a21be">booll</a> (bool value)</td></tr>
<tr class="memdesc:a988e27720b998e85472d3e1b198a21be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a literal node representing a <a class="el" href="structcerata_1_1_boolean.html" title="Boolean type.">Boolean</a>. <br /></td></tr>
<tr class="separator:a988e27720b998e85472d3e1b198a21be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dedad08e1c760104489facb8e7f8455"><td class="memItemLeft" align="right" valign="top"><a id="a6dedad08e1c760104489facb8e7f8455"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_port.html">Port</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a6dedad08e1c760104489facb8e7f8455">port</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;type, <a class="el" href="classcerata_1_1_term.html#ad5d2b86b16059306d8dbf73a0c972dad">Term::Dir</a> dir, const std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt; &amp;domain=<a class="el" href="namespacecerata.html#a54354555fa54fe1eb3a916d4e00b8103">default_domain</a>())</td></tr>
<tr class="memdesc:a6dedad08e1c760104489facb8e7f8455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new port with some name, type and direction. <br /></td></tr>
<tr class="separator:a6dedad08e1c760104489facb8e7f8455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e7fa26a88a414b669bb5bc490b9556"><td class="memItemLeft" align="right" valign="top"><a id="a52e7fa26a88a414b669bb5bc490b9556"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_port.html">Port</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a52e7fa26a88a414b669bb5bc490b9556">port</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;type, <a class="el" href="classcerata_1_1_term.html#ad5d2b86b16059306d8dbf73a0c972dad">Term::Dir</a> dir, const std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt; &amp;domain=<a class="el" href="namespacecerata.html#a54354555fa54fe1eb3a916d4e00b8103">default_domain</a>())</td></tr>
<tr class="memdesc:a52e7fa26a88a414b669bb5bc490b9556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new port. The name will be derived from the name of the type. <br /></td></tr>
<tr class="separator:a52e7fa26a88a414b669bb5bc490b9556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fe4d2cca1ac2499e1391b552ad00d6"><td class="memItemLeft" align="right" valign="top"><a id="a89fe4d2cca1ac2499e1391b552ad00d6"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_signal.html">Signal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a89fe4d2cca1ac2499e1391b552ad00d6">signal</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;type, const std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt; &amp;domain=<a class="el" href="namespacecerata.html#a54354555fa54fe1eb3a916d4e00b8103">default_domain</a>())</td></tr>
<tr class="memdesc:a89fe4d2cca1ac2499e1391b552ad00d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a> and return a smart pointer to it. <br /></td></tr>
<tr class="separator:a89fe4d2cca1ac2499e1391b552ad00d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094343c6ac9b6f522fb8dc34ddd0dd46"><td class="memItemLeft" align="right" valign="top"><a id="a094343c6ac9b6f522fb8dc34ddd0dd46"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_signal.html">Signal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a094343c6ac9b6f522fb8dc34ddd0dd46">signal</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;type, const std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt; &amp;domain=<a class="el" href="namespacecerata.html#a54354555fa54fe1eb3a916d4e00b8103">default_domain</a>())</td></tr>
<tr class="memdesc:a094343c6ac9b6f522fb8dc34ddd0dd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a> and return a smart pointer to it. The <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a> name is derived from the <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a> name. <br /></td></tr>
<tr class="separator:a094343c6ac9b6f522fb8dc34ddd0dd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8360c23043de7477e20798a05deb87a3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_stream.html">Stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a8360c23043de7477e20798a05deb87a3">stream</a> (const std::string &amp;name, const std::string &amp;element_name, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;element_type, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&gt; &amp;control={<a class="el" href="namespacecerata.html#ad5b6d584c1fef19fbe45e34e87a0e7c1">field</a>(<a class="el" href="classcerata_1_1_stream.html#a91f7222724c7e2adbbc58909b8b5de7e">Stream::valid</a>()), <a class="el" href="namespacecerata.html#ad5b6d584c1fef19fbe45e34e87a0e7c1">field</a>(<a class="el" href="classcerata_1_1_stream.html#a6f2d7b31ffc4599039f3aab0011b16fb">Stream::ready</a>()) -&gt;Reverse()})</td></tr>
<tr class="memdesc:a8360c23043de7477e20798a05deb87a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type and return a shared pointer to it.  <a href="namespacecerata.html#a8360c23043de7477e20798a05deb87a3">More...</a><br /></td></tr>
<tr class="separator:a8360c23043de7477e20798a05deb87a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e320a2edcd6a525af5915eb30d49dc"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_stream.html">Stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a64e320a2edcd6a525af5915eb30d49dc">stream</a> (const std::string &amp;element_name, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;element_type)</td></tr>
<tr class="memdesc:a64e320a2edcd6a525af5915eb30d49dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type with valid/ready bit control fields, named after the elements.  <a href="namespacecerata.html#a64e320a2edcd6a525af5915eb30d49dc">More...</a><br /></td></tr>
<tr class="separator:a64e320a2edcd6a525af5915eb30d49dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f2dccb73d5a6ef1b0ec5936e8fc369"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_stream.html">Stream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a08f2dccb73d5a6ef1b0ec5936e8fc369">stream</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;element_type)</td></tr>
<tr class="memdesc:a08f2dccb73d5a6ef1b0ec5936e8fc369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type with valid/ready bit control fields, named after the element type.  <a href="namespacecerata.html#a08f2dccb73d5a6ef1b0ec5936e8fc369">More...</a><br /></td></tr>
<tr class="separator:a08f2dccb73d5a6ef1b0ec5936e8fc369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11eb3ed7f490f23f1eb437c59bfef3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ae11eb3ed7f490f23f1eb437c59bfef3b">GetAllGraphs</a> (<a class="el" href="classcerata_1_1_graph.html">Graph</a> *top_graph, std::vector&lt; <a class="el" href="classcerata_1_1_graph.html">Graph</a> * &gt; *graphs_out, bool include_components=false)</td></tr>
<tr class="memdesc:ae11eb3ed7f490f23f1eb437c59bfef3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all potential child graphs of a graph.  <a href="namespacecerata.html#ae11eb3ed7f490f23f1eb437c59bfef3b">More...</a><br /></td></tr>
<tr class="separator:ae11eb3ed7f490f23f1eb437c59bfef3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26b5883f69351c04a193a319ea3e80f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ad26b5883f69351c04a193a319ea3e80f">GetAllObjects</a> (<a class="el" href="classcerata_1_1_component.html">Component</a> *top_component, std::vector&lt; <a class="el" href="classcerata_1_1_object.html">Object</a> * &gt; *objects_out, bool include_instances=false)</td></tr>
<tr class="memdesc:ad26b5883f69351c04a193a319ea3e80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all objects from a component.  <a href="namespacecerata.html#ad26b5883f69351c04a193a319ea3e80f">More...</a><br /></td></tr>
<tr class="separator:ad26b5883f69351c04a193a319ea3e80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4727414538446987e35ba70b3d73f978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4727414538446987e35ba70b3d73f978">GetAllTypes</a> (<a class="el" href="classcerata_1_1_component.html">Component</a> *top_component, std::vector&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> * &gt; *types_out, bool include_instances=false)</td></tr>
<tr class="memdesc:a4727414538446987e35ba70b3d73f978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all types used in a component, including nested types.  <a href="namespacecerata.html#a4727414538446987e35ba70b3d73f978">More...</a><br /></td></tr>
<tr class="separator:a4727414538446987e35ba70b3d73f978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f01c4617fd1008e26038f1a2ef625"><td class="memItemLeft" align="right" valign="top"><a id="ab94f01c4617fd1008e26038f1a2ef625"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ab94f01c4617fd1008e26038f1a2ef625">vector</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;width)</td></tr>
<tr class="memdesc:ab94f01c4617fd1008e26038f1a2ef625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector type, and return a shared pointer to it. <br /></td></tr>
<tr class="separator:ab94f01c4617fd1008e26038f1a2ef625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2585d3a94eff00e003138cf2c91eaa"><td class="memItemLeft" align="right" valign="top"><a id="a6f2585d3a94eff00e003138cf2c91eaa"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a6f2585d3a94eff00e003138cf2c91eaa">vector</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;width)</td></tr>
<tr class="memdesc:a6f2585d3a94eff00e003138cf2c91eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector type, and return a shared pointer to it. <br /></td></tr>
<tr class="separator:a6f2585d3a94eff00e003138cf2c91eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c9f996686c025fb29529946d7830c"><td class="memItemLeft" align="right" valign="top"><a id="aea0c9f996686c025fb29529946d7830c"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aea0c9f996686c025fb29529946d7830c">vector</a> (unsigned int width)</td></tr>
<tr class="memdesc:aea0c9f996686c025fb29529946d7830c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector type with an integer literal as width. <br /></td></tr>
<tr class="separator:aea0c9f996686c025fb29529946d7830c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76e7be2c238bcf15ac0ba7275d4caa6"><td class="memItemLeft" align="right" valign="top"><a id="ab76e7be2c238bcf15ac0ba7275d4caa6"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ab76e7be2c238bcf15ac0ba7275d4caa6">vector</a> (std::string name, unsigned int width)</td></tr>
<tr class="memdesc:ab76e7be2c238bcf15ac0ba7275d4caa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new vector type with an integer literal as width and a custom name. <br /></td></tr>
<tr class="separator:ab76e7be2c238bcf15ac0ba7275d4caa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23242b11c3eeeed443b99c4183dfd3df"><td class="memItemLeft" align="right" valign="top"><a id="a23242b11c3eeeed443b99c4183dfd3df"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a23242b11c3eeeed443b99c4183dfd3df">bit</a> (const std::string &amp;name=&quot;bit&quot;)</td></tr>
<tr class="memdesc:a23242b11c3eeeed443b99c4183dfd3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a static bit type. <br /></td></tr>
<tr class="separator:a23242b11c3eeeed443b99c4183dfd3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38baea85be258c82ebae0316cbec0e07"><td class="memItemLeft" align="right" valign="top"><a id="a38baea85be258c82ebae0316cbec0e07"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a38baea85be258c82ebae0316cbec0e07">boolean</a> ()</td></tr>
<tr class="memdesc:a38baea85be258c82ebae0316cbec0e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a static boolean type. <br /></td></tr>
<tr class="separator:a38baea85be258c82ebae0316cbec0e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84850e14c4b37fa654fee0df615abe28"><td class="memItemLeft" align="right" valign="top"><a id="a84850e14c4b37fa654fee0df615abe28"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a84850e14c4b37fa654fee0df615abe28">integer</a> ()</td></tr>
<tr class="memdesc:a84850e14c4b37fa654fee0df615abe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a static integer type. <br /></td></tr>
<tr class="separator:a84850e14c4b37fa654fee0df615abe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25c6ab0d58cb51648b0930d72c21276"><td class="memItemLeft" align="right" valign="top"><a id="aa25c6ab0d58cb51648b0930d72c21276"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aa25c6ab0d58cb51648b0930d72c21276">string</a> ()</td></tr>
<tr class="memdesc:aa25c6ab0d58cb51648b0930d72c21276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a static string type. <br /></td></tr>
<tr class="separator:aa25c6ab0d58cb51648b0930d72c21276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b6d584c1fef19fbe45e34e87a0e7c1"><td class="memItemLeft" align="right" valign="top"><a id="ad5b6d584c1fef19fbe45e34e87a0e7c1"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ad5b6d584c1fef19fbe45e34e87a0e7c1">field</a> (const std::string &amp;name, const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;type, bool reverse=false, bool sep=true)</td></tr>
<tr class="memdesc:ad5b6d584c1fef19fbe45e34e87a0e7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new RecordField, and return a shared pointer to it. <br /></td></tr>
<tr class="separator:ad5b6d584c1fef19fbe45e34e87a0e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730e533dc32a2b395cfb37c6df101492"><td class="memItemLeft" align="right" valign="top"><a id="a730e533dc32a2b395cfb37c6df101492"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a730e533dc32a2b395cfb37c6df101492">field</a> (const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;type, bool reverse=false, bool sep=true)</td></tr>
<tr class="memdesc:a730e533dc32a2b395cfb37c6df101492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new RecordField, and return a shared pointer to it. The name will be taken from the type. <br /></td></tr>
<tr class="separator:a730e533dc32a2b395cfb37c6df101492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa780bcf02e7f9a31222621e6dfcc4bc5"><td class="memItemLeft" align="right" valign="top"><a id="aa780bcf02e7f9a31222621e6dfcc4bc5"></a>
std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aa780bcf02e7f9a31222621e6dfcc4bc5">NoSep</a> (std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt; <a class="el" href="namespacecerata.html#ad5b6d584c1fef19fbe45e34e87a0e7c1">field</a>)</td></tr>
<tr class="memdesc:aa780bcf02e7f9a31222621e6dfcc4bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to disable the separator for a record field. <br /></td></tr>
<tr class="separator:aa780bcf02e7f9a31222621e6dfcc4bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc8a4ad689357b0d71c15b08860c318"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_record.html">Record</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4fc8a4ad689357b0d71c15b08860c318">record</a> (const std::string &amp;name, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&gt; &amp;fields)</td></tr>
<tr class="memdesc:a4fc8a4ad689357b0d71c15b08860c318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type, and return a shared pointer to it.  <a href="namespacecerata.html#a4fc8a4ad689357b0d71c15b08860c318">More...</a><br /></td></tr>
<tr class="separator:a4fc8a4ad689357b0d71c15b08860c318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d9b09ffa347f4fcfbe79b729b2b812"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_record.html">Record</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ae7d9b09ffa347f4fcfbe79b729b2b812">record</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ae7d9b09ffa347f4fcfbe79b729b2b812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, empty <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type, and return a shared pointer to it.  <a href="namespacecerata.html#ae7d9b09ffa347f4fcfbe79b729b2b812">More...</a><br /></td></tr>
<tr class="separator:ae7d9b09ffa347f4fcfbe79b729b2b812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e674f3ac0762441b36565b8822f972"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_record.html">Record</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ac6e674f3ac0762441b36565b8822f972">record</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&gt; &amp;fields)</td></tr>
<tr class="memdesc:ac6e674f3ac0762441b36565b8822f972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, anonymous <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type, and return a shared pointer to it.  <a href="namespacecerata.html#ac6e674f3ac0762441b36565b8822f972">More...</a><br /></td></tr>
<tr class="separator:ac6e674f3ac0762441b36565b8822f972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb78d0ac259a38f89765d2f96b682f2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_record.html">Record</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a7fb78d0ac259a38f89765d2f96b682f2">record</a> (const std::initializer_list&lt; std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&gt; &amp;fields)</td></tr>
<tr class="memdesc:a7fb78d0ac259a38f89765d2f96b682f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, anonymous <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type, and return a shared pointer to it.  <a href="namespacecerata.html#a7fb78d0ac259a38f89765d2f96b682f2">More...</a><br /></td></tr>
<tr class="separator:a7fb78d0ac259a38f89765d2f96b682f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60e7833914c40b5b789ebc337461fde"><td class="memItemLeft" align="right" valign="top"><a id="ac60e7833914c40b5b789ebc337461fde"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ac60e7833914c40b5b789ebc337461fde">ToUpper</a> (std::string str)</td></tr>
<tr class="memdesc:ac60e7833914c40b5b789ebc337461fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to upper-case. <br /></td></tr>
<tr class="separator:ac60e7833914c40b5b789ebc337461fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7986d888e4c15349a291dc91c3498ce3"><td class="memItemLeft" align="right" valign="top"><a id="a7986d888e4c15349a291dc91c3498ce3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a7986d888e4c15349a291dc91c3498ce3">ToLower</a> (std::string str)</td></tr>
<tr class="memdesc:a7986d888e4c15349a291dc91c3498ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to lower-case. <br /></td></tr>
<tr class="separator:a7986d888e4c15349a291dc91c3498ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae290cf0a3c1ebde410ce12c900ca7743"><td class="memItemLeft" align="right" valign="top"><a id="ae290cf0a3c1ebde410ce12c900ca7743"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ae290cf0a3c1ebde410ce12c900ca7743">ToString</a> (const std::unordered_map&lt; std::string, std::string &gt; &amp;meta)</td></tr>
<tr class="memdesc:ae290cf0a3c1ebde410ce12c900ca7743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable representation of an unordered map of string key-value pairs. <br /></td></tr>
<tr class="separator:ae290cf0a3c1ebde410ce12c900ca7743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5e023bf7fa158ab1719f34bea69232"><td class="memItemLeft" align="right" valign="top"><a id="a5a5e023bf7fa158ab1719f34bea69232"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5a5e023bf7fa158ab1719f34bea69232">CreateDir</a> (const std::string &amp;dir_name)</td></tr>
<tr class="memdesc:a5a5e023bf7fa158ab1719f34bea69232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory. <br /></td></tr>
<tr class="separator:a5a5e023bf7fa158ab1719f34bea69232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d99ff165c6a0643187e19cfc324048e"><td class="memItemLeft" align="right" valign="top"><a id="a8d99ff165c6a0643187e19cfc324048e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a8d99ff165c6a0643187e19cfc324048e">FileExists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a8d99ff165c6a0643187e19cfc324048e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if file exists. <br /></td></tr>
<tr class="separator:a8d99ff165c6a0643187e19cfc324048e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a000b15bcd5fe8bf3dff07f4205bf1a"><td class="memItemLeft" align="right" valign="top"><a id="a5a000b15bcd5fe8bf3dff07f4205bf1a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5a000b15bcd5fe8bf3dff07f4205bf1a">version</a> ()</td></tr>
<tr class="memdesc:a5a000b15bcd5fe8bf3dff07f4205bf1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return library version. <br /></td></tr>
<tr class="separator:a5a000b15bcd5fe8bf3dff07f4205bf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafda8d395563849d131917164abd14b1"><td class="memTemplParams" colspan="2"><a id="aafda8d395563849d131917164abd14b1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafda8d395563849d131917164abd14b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aafda8d395563849d131917164abd14b1">Contains</a> (const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;list, const std::shared_ptr&lt; T &gt; &amp;item)</td></tr>
<tr class="memdesc:aafda8d395563849d131917164abd14b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if vector contains item, false otherwise. <br /></td></tr>
<tr class="separator:aafda8d395563849d131917164abd14b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9931e76a290bd85eed2a3cec5c9f17"><td class="memTemplParams" colspan="2"><a id="a8c9931e76a290bd85eed2a3cec5c9f17"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c9931e76a290bd85eed2a3cec5c9f17"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a8c9931e76a290bd85eed2a3cec5c9f17">Contains</a> (const std::vector&lt; std::weak_ptr&lt; T &gt;&gt; &amp;list, const std::weak_ptr&lt; T &gt; &amp;item)</td></tr>
<tr class="memdesc:a8c9931e76a290bd85eed2a3cec5c9f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if vector contains item, false otherwise. <br /></td></tr>
<tr class="separator:a8c9931e76a290bd85eed2a3cec5c9f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716e6b4e5154ec6efb8004d8264cbb6f"><td class="memTemplParams" colspan="2"><a id="a716e6b4e5154ec6efb8004d8264cbb6f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a716e6b4e5154ec6efb8004d8264cbb6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a716e6b4e5154ec6efb8004d8264cbb6f">Contains</a> (const std::vector&lt; T * &gt; &amp;list, T *item)</td></tr>
<tr class="memdesc:a716e6b4e5154ec6efb8004d8264cbb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if vector contains item, false otherwise. <br /></td></tr>
<tr class="separator:a716e6b4e5154ec6efb8004d8264cbb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c3951234b2cfd53f1b359aea4f6d98"><td class="memTemplParams" colspan="2"><a id="a36c3951234b2cfd53f1b359aea4f6d98"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a36c3951234b2cfd53f1b359aea4f6d98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a36c3951234b2cfd53f1b359aea4f6d98">Append</a> (std::vector&lt; T &gt; *list_a, const std::vector&lt; T &gt; &amp;list_b)</td></tr>
<tr class="memdesc:a36c3951234b2cfd53f1b359aea4f6d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append list b to list a. <br /></td></tr>
<tr class="separator:a36c3951234b2cfd53f1b359aea4f6d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce25c4ad82016c23b8c6536fe5215fd"><td class="memTemplParams" colspan="2"><a id="adce25c4ad82016c23b8c6536fe5215fd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adce25c4ad82016c23b8c6536fe5215fd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#adce25c4ad82016c23b8c6536fe5215fd">Merge</a> (std::initializer_list&lt; std::vector&lt; T &gt;&gt; lists)</td></tr>
<tr class="memdesc:adce25c4ad82016c23b8c6536fe5215fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a list of vectors into one vector. <br /></td></tr>
<tr class="separator:adce25c4ad82016c23b8c6536fe5215fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bd5cd9b648cf01bb01bfabee121a06"><td class="memTemplParams" colspan="2"><a id="a09bd5cd9b648cf01bb01bfabee121a06"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a09bd5cd9b648cf01bb01bfabee121a06"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a09bd5cd9b648cf01bb01bfabee121a06">Merge</a> (std::initializer_list&lt; std::unordered_map&lt; T, U &gt;&gt; lists)</td></tr>
<tr class="memdesc:a09bd5cd9b648cf01bb01bfabee121a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a list of unordered maps into one unordered map. <br /></td></tr>
<tr class="separator:a09bd5cd9b648cf01bb01bfabee121a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab2a8248c5475a1989bdbcd9c976768"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ab2a8248c5475a1989bdbcd9c976768"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a1ab2a8248c5475a1989bdbcd9c976768">Remove</a> (std::vector&lt; std::shared_ptr&lt; T &gt;&gt; *list, const std::shared_ptr&lt; T &gt; &amp;item)</td></tr>
<tr class="memdesc:a1ab2a8248c5475a1989bdbcd9c976768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from a vector, returning false if it was not in the vector, true otherwise.  <a href="namespacecerata.html#a1ab2a8248c5475a1989bdbcd9c976768">More...</a><br /></td></tr>
<tr class="separator:a1ab2a8248c5475a1989bdbcd9c976768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e6e9ce64ee0a6c887bc11b797b8a37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34e6e9ce64ee0a6c887bc11b797b8a37"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a34e6e9ce64ee0a6c887bc11b797b8a37">ToRawPointers</a> (const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;list)</td></tr>
<tr class="memdesc:a34e6e9ce64ee0a6c887bc11b797b8a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of shared pointers to raw pointers.  <a href="namespacecerata.html#a34e6e9ce64ee0a6c887bc11b797b8a37">More...</a><br /></td></tr>
<tr class="separator:a34e6e9ce64ee0a6c887bc11b797b8a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b23dc73eb07325ba56e048ed1e3d0b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b23dc73eb07325ba56e048ed1e3d0b9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a1b23dc73eb07325ba56e048ed1e3d0b9">ToRawPointers</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;list)</td></tr>
<tr class="memdesc:a1b23dc73eb07325ba56e048ed1e3d0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of unique pointers to raw pointers.  <a href="namespacecerata.html#a1b23dc73eb07325ba56e048ed1e3d0b9">More...</a><br /></td></tr>
<tr class="separator:a1b23dc73eb07325ba56e048ed1e3d0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f450a7110543c4b320aaef2ca3158aa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4f450a7110543c4b320aaef2ca3158aa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4f450a7110543c4b320aaef2ca3158aa">As</a> (const std::vector&lt; U * &gt; &amp;vec)</td></tr>
<tr class="memdesc:a4f450a7110543c4b320aaef2ca3158aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a vector of pointers to some other type.  <a href="namespacecerata.html#a4f450a7110543c4b320aaef2ca3158aa">More...</a><br /></td></tr>
<tr class="separator:a4f450a7110543c4b320aaef2ca3158aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316a3ab939e35d12995c407d735434ca"><td class="memTemplParams" colspan="2"><a id="a316a3ab939e35d12995c407d735434ca"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a316a3ab939e35d12995c407d735434ca"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a316a3ab939e35d12995c407d735434ca">Unique</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a316a3ab939e35d12995c407d735434ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of a vector without any duplicates. <br /></td></tr>
<tr class="separator:a316a3ab939e35d12995c407d735434ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a746df770052621a3ef83e40927534"><td class="memTemplParams" colspan="2"><a id="ab0a746df770052621a3ef83e40927534"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0a746df770052621a3ef83e40927534"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#ab0a746df770052621a3ef83e40927534">FilterDuplicates</a> (std::vector&lt; T &gt; *vec)</td></tr>
<tr class="memdesc:ab0a746df770052621a3ef83e40927534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter duplicate entries from a vector. <br /></td></tr>
<tr class="separator:ab0a746df770052621a3ef83e40927534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dd5e321bc1aed05e48d9f5a4842302"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8dd5e321bc1aed05e48d9f5a4842302"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecerata.html#aa8dd5e321bc1aed05e48d9f5a4842302">ToString</a> ()</td></tr>
<tr class="memdesc:aa8dd5e321bc1aed05e48d9f5a4842302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable string from a type.  <a href="namespacecerata.html#aa8dd5e321bc1aed05e48d9f5a4842302">More...</a><br /></td></tr>
<tr class="separator:aa8dd5e321bc1aed05e48d9f5a4842302"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5cb5dc84674f8863f61b2a997181ce91"><td class="memItemLeft" align="right" valign="top"><a id="a5cb5dc84674f8863f61b2a997181ce91"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a5cb5dc84674f8863f61b2a997181ce91">CERATA_LOG_DEBUG</a> = -1</td></tr>
<tr class="memdesc:a5cb5dc84674f8863f61b2a997181ce91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug level. <br /></td></tr>
<tr class="separator:a5cb5dc84674f8863f61b2a997181ce91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4870ffebda0cabb4058799d58ad9f8ae"><td class="memItemLeft" align="right" valign="top"><a id="a4870ffebda0cabb4058799d58ad9f8ae"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4870ffebda0cabb4058799d58ad9f8ae">CERATA_LOG_INFO</a> = 0</td></tr>
<tr class="memdesc:a4870ffebda0cabb4058799d58ad9f8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information level. <br /></td></tr>
<tr class="separator:a4870ffebda0cabb4058799d58ad9f8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db829eebdd52ddd870f9cda54348999"><td class="memItemLeft" align="right" valign="top"><a id="a4db829eebdd52ddd870f9cda54348999"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a4db829eebdd52ddd870f9cda54348999">CERATA_LOG_WARNING</a> = 1</td></tr>
<tr class="memdesc:a4db829eebdd52ddd870f9cda54348999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warning level. <br /></td></tr>
<tr class="separator:a4db829eebdd52ddd870f9cda54348999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f306c2e65e0519ee17f38a9e33797d"><td class="memItemLeft" align="right" valign="top"><a id="a22f306c2e65e0519ee17f38a9e33797d"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a22f306c2e65e0519ee17f38a9e33797d">CERATA_LOG_ERROR</a> = 2</td></tr>
<tr class="memdesc:a22f306c2e65e0519ee17f38a9e33797d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error level. <br /></td></tr>
<tr class="separator:a22f306c2e65e0519ee17f38a9e33797d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218dc6a092b811483542ed281081b966"><td class="memItemLeft" align="right" valign="top"><a id="a218dc6a092b811483542ed281081b966"></a>
constexpr <a class="el" href="namespacecerata.html#a3fcbbd525dac4039659ccb1f5a6bb256">LogLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecerata.html#a218dc6a092b811483542ed281081b966">CERATA_LOG_FATAL</a> = 3</td></tr>
<tr class="memdesc:a218dc6a092b811483542ed281081b966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fatal level; tool should exit. <br /></td></tr>
<tr class="separator:a218dc6a092b811483542ed281081b966"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains every Cerata class, function, etc... </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4f450a7110543c4b320aaef2ca3158aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f450a7110543c4b320aaef2ca3158aa">&#9670;&nbsp;</a></span>As()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T *&gt; cerata::As </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; U * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast a vector of pointers to some other type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the objects being pointed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector of pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of raw pointers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00155">155</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a id="aa7554850cf2775a320602b3739d980bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7554850cf2775a320602b3739d980bf">&#9670;&nbsp;</a></span>AttachSignalArrayToNodeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcerata_1_1_signal_array.html">SignalArray</a> * cerata::AttachSignalArrayToNodeArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_component.html">Component</a> *&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_node_array.html">NodeArray</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecerata.html#aaadbf80a46cf891ebe1a1defc66cecb9">NodeMap</a> *&#160;</td>
          <td class="paramname"><em>rebinding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a <a class="el" href="classcerata_1_1_signal_array.html" title="An array of signal nodes.">SignalArray</a> to a <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a>, redirecting all edges through the new <a class="el" href="classcerata_1_1_signal_array.html" title="An array of signal nodes.">SignalArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>The component to add and own the <a class="el" href="classcerata_1_1_signal_array.html" title="An array of signal nodes.">SignalArray</a>. </td></tr>
    <tr><td class="paramname">array</td><td>The <a class="el" href="classcerata_1_1_node_array.html" title="An array of nodes.">NodeArray</a> to attach the <a class="el" href="classcerata_1_1_signal_array.html" title="An array of signal nodes.">SignalArray</a> to. </td></tr>
    <tr><td class="paramname">rebinding</td><td>A pointer to a NodeMap to which all rebound Nodes will be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classcerata_1_1_signal_array.html" title="An array of signal nodes.">SignalArray</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="edge_8cc_source.html#l00327">327</a> of file <a class="el" href="edge_8cc_source.html">edge.cc</a>.</p>

</div>
</div>
<a id="aae3d7c4f3efb99d3dcee77c87024208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3d7c4f3efb99d3dcee77c87024208f">&#9670;&nbsp;</a></span>AttachSignalToNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcerata_1_1_signal.html">Signal</a> * cerata::AttachSignalToNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_component.html">Component</a> *&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcerata_1_1_normal_node.html">NormalNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecerata.html#aaadbf80a46cf891ebe1a1defc66cecb9">NodeMap</a> *&#160;</td>
          <td class="paramname"><em>rebinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a> to a <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a>, redirecting all edges through the new <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>The component to add and own the <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a>. </td></tr>
    <tr><td class="paramname">node</td><td>The <a class="el" href="classcerata_1_1_node.html" title="A node.">Node</a> to attach the <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a> to. </td></tr>
    <tr><td class="paramname">rebinding</td><td>A pointer to a NodeMap to which all rebound Nodes will be appended. </td></tr>
    <tr><td class="paramname">name</td><td>A name for the new <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <a class="el" href="classcerata_1_1_signal.html" title="A Signal Node.">Signal</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="edge_8cc_source.html#l00254">254</a> of file <a class="el" href="edge_8cc_source.html">edge.cc</a>.</p>

</div>
</div>
<a id="a7bca1eba253dcd02cce5b31a09a239a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bca1eba253dcd02cce5b31a09a239a8">&#9670;&nbsp;</a></span>Connect() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt; cerata::Connect </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect two nodes, returns the corresponding edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination node. </td></tr>
    <tr><td class="paramname">src</td><td>The source node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge connecting the nodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="edge_8cc_source.html#l00227">227</a> of file <a class="el" href="edge_8cc_source.html">edge.cc</a>.</p>

</div>
</div>
<a id="ac5420154c855d31f11018dcd6c183502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5420154c855d31f11018dcd6c183502">&#9670;&nbsp;</a></span>Connect() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt; cerata::Connect </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect two nodes, returns the corresponding edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination node. </td></tr>
    <tr><td class="paramname">src</td><td>The source node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge connecting the nodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="edge_8cc_source.html#l00223">223</a> of file <a class="el" href="edge_8cc_source.html">edge.cc</a>.</p>

</div>
</div>
<a id="a21edb913c7d1cdd7e44c7bf4eaf4b6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21edb913c7d1cdd7e44c7bf4eaf4b6f8">&#9670;&nbsp;</a></span>Connect() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt; cerata::Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect two nodes, returns the corresponding edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination node. </td></tr>
    <tr><td class="paramname">src</td><td>The source node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge connecting the nodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="edge_8cc_source.html#l00219">219</a> of file <a class="el" href="edge_8cc_source.html">edge.cc</a>.</p>

</div>
</div>
<a id="a75a4a91a13db9c5da9a901069a1fa244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a4a91a13db9c5da9a901069a1fa244">&#9670;&nbsp;</a></span>Connect() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt; cerata::Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect two nodes, returns the corresponding edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination node. </td></tr>
    <tr><td class="paramname">src</td><td>The source node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge connecting the nodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="edge_8cc_source.html#l00068">68</a> of file <a class="el" href="edge_8cc_source.html">edge.cc</a>.</p>

</div>
</div>
<a id="a95f7364223f66e39d88afa42d116f3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f7364223f66e39d88afa42d116f3f4">&#9670;&nbsp;</a></span>Connect() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_edge.html">Edge</a> &gt; cerata::Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect a string literal to another node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination node. </td></tr>
    <tr><td class="paramname">str</td><td>A string out of which a string literal node will be created.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edge connecting the nodes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="edge_8cc_source.html#l00412">412</a> of file <a class="el" href="edge_8cc_source.html">edge.cc</a>.</p>

</div>
</div>
<a id="ae11eb3ed7f490f23f1eb437c59bfef3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11eb3ed7f490f23f1eb437c59bfef3b">&#9670;&nbsp;</a></span>GetAllGraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cerata::GetAllGraphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_graph.html">Graph</a> *&#160;</td>
          <td class="paramname"><em>top_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcerata_1_1_graph.html">Graph</a> * &gt; *&#160;</td>
          <td class="paramname"><em>graphs_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_components</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all potential child graphs of a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_graph</td><td>The top-level graph to inspect. </td></tr>
    <tr><td class="paramname">graphs_out</td><td>A list of graphs to append the output to. </td></tr>
    <tr><td class="paramname">include_components</td><td>Whether to recurse down the components used by any instances in the graph. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8cc_source.html#l00027">27</a> of file <a class="el" href="transform_8cc_source.html">transform.cc</a>.</p>

</div>
</div>
<a id="ad26b5883f69351c04a193a319ea3e80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26b5883f69351c04a193a319ea3e80f">&#9670;&nbsp;</a></span>GetAllObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cerata::GetAllObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_component.html">Component</a> *&#160;</td>
          <td class="paramname"><em>top_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcerata_1_1_object.html">Object</a> * &gt; *&#160;</td>
          <td class="paramname"><em>objects_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_instances</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all objects from a component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_component</td><td>The top-level component to inspect. </td></tr>
    <tr><td class="paramname">objects_out</td><td>A list of objects to append the output to. </td></tr>
    <tr><td class="paramname">include_instances</td><td>Whether to recurse down the instances in the top-level graph. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8cc_source.html#l00048">48</a> of file <a class="el" href="transform_8cc_source.html">transform.cc</a>.</p>

</div>
</div>
<a id="a4727414538446987e35ba70b3d73f978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4727414538446987e35ba70b3d73f978">&#9670;&nbsp;</a></span>GetAllTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cerata::GetAllTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcerata_1_1_component.html">Component</a> *&#160;</td>
          <td class="paramname"><em>top_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> * &gt; *&#160;</td>
          <td class="paramname"><em>types_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_instances</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all types used in a component, including nested types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_component</td><td>The top-level component to inspect. </td></tr>
    <tr><td class="paramname">types_out</td><td>A list of types to append the output to. </td></tr>
    <tr><td class="paramname">include_instances</td><td>Whether to recurse down the instances in the top-level graph. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="transform_8cc_source.html#l00061">61</a> of file <a class="el" href="transform_8cc_source.html">transform.cc</a>.</p>

</div>
</div>
<a id="a66a3eb243cac49627d6594047333032f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a3eb243cac49627d6594047333032f">&#9670;&nbsp;</a></span>GetObjectReferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cerata::GetObjectReferences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcerata_1_1_object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcerata_1_1_object.html">Object</a> * &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get any sub-objects that are used by an object, e.g. type generic nodes or array size nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The object from which to derive the required objects. </td></tr>
    <tr><td class="paramname">out</td><td>The output. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="node_8cc_source.html#l00247">247</a> of file <a class="el" href="node_8cc_source.html">node.cc</a>.</p>

</div>
</div>
<a id="aee5648b64e2007b77290b7a584d5db6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5648b64e2007b77290b7a584d5db6a">&#9670;&nbsp;</a></span>parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_parameter.html">Parameter</a> &gt; cerata::parameter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_literal.html">Literal</a> &gt;&#160;</td>
          <td class="paramname"><em>default_value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new parameter. </p>
<p>If no default value is supplied, a default value is implicitly created based on the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the parameter. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the parameter. </td></tr>
    <tr><td class="paramname">default_value</td><td>The default value of the parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new parameter. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parameter_8cc_source.html#l00045">45</a> of file <a class="el" href="parameter_8cc_source.html">parameter.cc</a>.</p>

</div>
</div>
<a id="aaa199912b79794ece2bf4f491251833d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa199912b79794ece2bf4f491251833d">&#9670;&nbsp;</a></span>RawValueOf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cerata::RawValueOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcerata_1_1_literal.html">Literal</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the raw value of a literal node. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The compile-time return type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to obtain the value from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of type T. </dd></dl>

<p class="definition">Definition at line <a class="el" href="literal_8h_source.html#l00108">108</a> of file <a class="el" href="literal_8h_source.html">literal.h</a>.</p>

</div>
</div>
<a id="a6ed3d124db6df73c0acdb6b6191a59cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed3d124db6df73c0acdb6b6191a59cf">&#9670;&nbsp;</a></span>RawValueOf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cerata::RawValueOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcerata_1_1_literal.html">Literal</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template specialization for RawValueOf&lt;bool&gt; </p>
<p>Template specialization for <a class="el" href="namespacecerata.html#aaa199912b79794ece2bf4f491251833d" title="Obtain the raw value of a literal node.">RawValueOf&lt;std::string&gt;</a></p>
<p>Template specialization for RawValueOf&lt;int&gt; </p>

<p class="definition">Definition at line <a class="el" href="literal_8h_source.html#l00112">112</a> of file <a class="el" href="literal_8h_source.html">literal.h</a>.</p>

</div>
</div>
<a id="a7fb78d0ac259a38f89765d2f96b682f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb78d0ac259a38f89765d2f96b682f2">&#9670;&nbsp;</a></span>record() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_record.html">Record</a> &gt; cerata::record </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, anonymous <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type, and return a shared pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fields</td><td>The fields of the record type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8cc_source.html#l00320">320</a> of file <a class="el" href="type_8cc_source.html">type.cc</a>.</p>

</div>
</div>
<a id="ae7d9b09ffa347f4fcfbe79b729b2b812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d9b09ffa347f4fcfbe79b729b2b812">&#9670;&nbsp;</a></span>record() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_record.html">Record</a> &gt; cerata::record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, empty <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type, and return a shared pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8cc_source.html#l00312">312</a> of file <a class="el" href="type_8cc_source.html">type.cc</a>.</p>

</div>
</div>
<a id="a4fc8a4ad689357b0d71c15b08860c318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc8a4ad689357b0d71c15b08860c318">&#9670;&nbsp;</a></span>record() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_record.html">Record</a> &gt; cerata::record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type, and return a shared pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type. </td></tr>
    <tr><td class="paramname">fields</td><td>The fields of the record type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8cc_source.html#l00308">308</a> of file <a class="el" href="type_8cc_source.html">type.cc</a>.</p>

</div>
</div>
<a id="ac6e674f3ac0762441b36565b8822f972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e674f3ac0762441b36565b8822f972">&#9670;&nbsp;</a></span>record() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_record.html">Record</a> &gt; cerata::record </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, anonymous <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> type, and return a shared pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fields</td><td>The fields of the record type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a> <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="type_8cc_source.html#l00316">316</a> of file <a class="el" href="type_8cc_source.html">type.cc</a>.</p>

</div>
</div>
<a id="a1ab2a8248c5475a1989bdbcd9c976768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab2a8248c5475a1989bdbcd9c976768">&#9670;&nbsp;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cerata::Remove </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an item from a vector, returning false if it was not in the vector, true otherwise. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the item </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The vector </td></tr>
    <tr><td class="paramname">item</td><td>The item to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item was in list and got removed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00108">108</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a id="a1a4f0ee8ed52feb08a7124933579b63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4f0ee8ed52feb08a7124933579b63d">&#9670;&nbsp;</a></span>signal_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_signal_array.html">SignalArray</a> &gt; cerata::signal_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structcerata_1_1_clock_domain.html">ClockDomain</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code><a class="el" href="namespacecerata.html#a54354555fa54fe1eb3a916d4e00b8103">default_domain</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new node array and return a shared pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node array. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the nodes in the node array. </td></tr>
    <tr><td class="paramname">size</td><td>The size node of the node array. </td></tr>
    <tr><td class="paramname">domain</td><td>The clock domain of the nodes in the node array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the new node array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8cc_source.html#l00198">198</a> of file <a class="el" href="array_8cc_source.html">array.cc</a>.</p>

</div>
</div>
<a id="a08f2dccb73d5a6ef1b0ec5936e8fc369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f2dccb73d5a6ef1b0ec5936e8fc369">&#9670;&nbsp;</a></span>stream() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_stream.html">Stream</a> &gt; cerata::stream </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>element_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type with valid/ready bit control fields, named after the element type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_type</td><td>The type of the elements on the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the new <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8cc_source.html#l00068">68</a> of file <a class="el" href="stream_8cc_source.html">stream.cc</a>.</p>

</div>
</div>
<a id="a64e320a2edcd6a525af5915eb30d49dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e320a2edcd6a525af5915eb30d49dc">&#9670;&nbsp;</a></span>stream() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_stream.html">Stream</a> &gt; cerata::stream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>element_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type with valid/ready bit control fields, named after the elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_name</td><td>The name of the elements. </td></tr>
    <tr><td class="paramname">element_type</td><td>The type of the elements on the stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the new <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8cc_source.html#l00064">64</a> of file <a class="el" href="stream_8cc_source.html">stream.cc</a>.</p>

</div>
</div>
<a id="a8360c23043de7477e20798a05deb87a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8360c23043de7477e20798a05deb87a3">&#9670;&nbsp;</a></span>stream() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classcerata_1_1_stream.html">Stream</a> &gt; cerata::stream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcerata_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>element_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcerata_1_1_field.html">Field</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>control</em> = <code>{<a class="el" href="namespacecerata.html#ad5b6d584c1fef19fbe45e34e87a0e7c1">field</a>(<a class="el" href="classcerata_1_1_stream.html#a91f7222724c7e2adbbc58909b8b5de7e">Stream::valid</a>()),&#160;<a class="el" href="namespacecerata.html#ad5b6d584c1fef19fbe45e34e87a0e7c1">field</a>(<a class="el" href="classcerata_1_1_stream.html#a6f2d7b31ffc4599039f3aab0011b16fb">Stream::ready</a>())&#160;-&gt;Reverse()}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type and return a shared pointer to it. </p>
<p>The <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type is just a sugar coated version of a <a class="el" href="classcerata_1_1_record.html" title="A Record type containing zero or more fields.">Record</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the <a class="el" href="classcerata_1_1_type.html" title="A Type.">Type</a>. </td></tr>
    <tr><td class="paramname">element_name</td><td>The name of the elements. </td></tr>
    <tr><td class="paramname">element_type</td><td>The type of the elements on the stream. </td></tr>
    <tr><td class="paramname">control</td><td>Fields that should travel on the stream as control information. This is a valid and ready signal by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the new <a class="el" href="classcerata_1_1_stream.html" title="A Stream type.">Stream</a> type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8cc_source.html#l00057">57</a> of file <a class="el" href="stream_8cc_source.html">stream.cc</a>.</p>

</div>
</div>
<a id="a34e6e9ce64ee0a6c887bc11b797b8a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e6e9ce64ee0a6c887bc11b797b8a37">&#9670;&nbsp;</a></span>ToRawPointers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T *&gt; cerata::ToRawPointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of shared pointers to raw pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the objects being pointed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of shared pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of raw pointers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00125">125</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a id="a1b23dc73eb07325ba56e048ed1e3d0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b23dc73eb07325ba56e048ed1e3d0b9">&#9670;&nbsp;</a></span>ToRawPointers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T *&gt; cerata::ToRawPointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of unique pointers to raw pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the objects being pointed to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of unique pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of raw pointers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00140">140</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
<a id="aa8dd5e321bc1aed05e48d9f5a4842302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dd5e321bc1aed05e48d9f5a4842302">&#9670;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string cerata::ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable string from a type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The human-readable string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utils_8h_source.html#l00185">185</a> of file <a class="el" href="utils_8h_source.html">utils.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecerata.html">cerata</a></li>
    <li class="footer">Generated on Tue Nov 10 2020 12:46:19 for Cerata by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
